<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta name="viewport" content="user-scalable=1.0,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="robots" content="noindex,nofollow">
    <link type="text/css" href="styles/style.css" media="screen" rel="stylesheet" title="CSS" />
    <link type="text/css" href="styles/xterm.css" media="screen" rel="stylesheet" title="CSS" />
    <link rel="apple-touch-icon" href="/favicon-303x303.png" />
    <script type="text/javascript" src="scripts/common-0.0.1{{min}}.js"></script>
    <script type="text/javascript" src="scripts/agent-desktop-0.0.2{{min}}.js"></script>
    <script type="text/javascript" src="scripts/amt-desktop-0.0.2{{min}}.js"></script>
    <script type="text/javascript" src="scripts/amt-terminal-0.0.2{{min}}.js"></script>
    <script type="text/javascript" src="scripts/zlib{{min}}.js"></script>
    <script type="text/javascript" src="scripts/zlib-inflate{{min}}.js"></script>
    <script type="text/javascript" src="scripts/zlib-adler32{{min}}.js"></script>
    <script type="text/javascript" src="scripts/zlib-crc32{{min}}.js"></script>
    <script type="text/javascript" src="scripts/xterm-min.js"></script>
    <script type="text/javascript" src="scripts/xterm-addon-fit-min.js"></script>
    <script keeplink=1 type="text/javascript" src="scripts/webm-writer.js"></script>
    <script keeplink=1 type="text/javascript" src="scripts/filesaver.min.js"></script>
</head>
<body style="overflow:hidden;background-color:black">
    <div id=p11 class="noselect" style="overflow:hidden">
        <div id=deskarea0>
            <div id=deskarea1 class="areaHead">
                <div class="toright2">
                    <div class='deskareaicon' title="Toggle View Mode" onclick="toggleAspectRatio(1)">&#8690;</div>&nbsp;
                    <input id="ConvertAsWebM" style="display:none" type=button value="Convert to WebM" onclick="saveAsWebMfile()">&nbsp;
                </div>
                <div>
                    <input id="OpenFileButton" type=button value="Open File..." onclick="openfile()" style="display:none">
                    <span id="deskstatus" style="line-height:22px;overflow:hidden;max-height:22px"></span>
                </div>
            </div>
            <div id=deskarea3x style="max-height:calc(100vh - 58px);height:calc(100vh - 58px);" onclick="togglePause()">
                <div id="bigok" style="display:none;left:calc((100vh / 2))"><b>&checkmark;</b></div>
                <div id="bigfail" style="display:none;left:calc((100vh / 2))"><b>&#10007;</b></div>
                <div id="metadatadiv" style="padding:20px;color:lightgrey;text-align:left;display:none"></div>
                <div id=DeskParent>
                    <canvas id=Desk width=640 height=480></canvas>
                </div>
                <div id=TermParent style="display:none">
                    <pre id=Term></pre>
                </div>
                <div id=XTermParent style="display:none;overflow:scroll;max-height:calc(100vh - 58px);height:calc(100vh - 58px)">
                </div>
                <div id=p11DeskConsoleMsg style="display:none;cursor:pointer;position:absolute;left:30px;top:17px;color:yellow;background-color:rgba(0,0,0,0.6);padding:10px;border-radius:5px" onclick=clearConsoleMsg()></div>
            </div>
            <div id=deskarea2 style="">
                <div class="areaProgress" style="cursor:pointer" onclick="progressBarSeek(event)"><div id="progressbar" style="height:6px;cursor:pointer"></div></div>
            </div>
            <div id=deskarea4 class="areaFoot">
                <div class="toright2">
                    <div id="timespan" style="padding-top:4px;padding-right:4px">00:00:00</div>
                </div>
                <div>
                    &nbsp;
                    <input id="PlayButton" type=button value="Play" disabled="disabled" onclick="play()">
                    <input id="PauseButton" type=button value="Pause" disabled="disabled" onclick="pause()">
                    <input id="RestartButton" type=button value="Restart" disabled="disabled" onclick="restart()">
                    <select id="PlaySpeed" onchange="this.blur();">
                        <option value=4>1/4 Speed</option>
                        <option value=2>1/2 Speed</option>
                        <option value=1 selected>Normal Speed</option>
                        <option value=0.5>2x Speed</option>
                        <option value=0.25>4x Speed</option>
                        <option value=0.1>10x Speed</option>
                    </select>
                    <input id="SeekBackwardButton" type=button value="<<" disabled="disabled" onclick="seekBackward()">
                    <input id="SeekForwardButton" type=button value=">>" disabled="disabled" onclick="seekForward()">
                </div>
            </div>
        </div>
        <div id=dialog class="noselect" style="display:none">
            <div id=dialogHeader>
                <div tabindex=0 id=id_dialogclose onclick=setDialogMode() onkeypress="if (event.key == 'Enter') setDialogMode()">&#x2716;</div>
                <div id=id_dialogtitle></div>
            </div>
            <div id=dialogBody>
                <div id=dialog1>
                    <div id=id_dialogMessage style=""></div>
                </div>
                <div id=dialog2 style="">
                    <div id=id_dialogOptions></div>
                </div>
            </div>
            <div id="idx_dlgButtonBar">
                <input id="idx_dlgCancelButton" type="button" value="Cancel" style="" onclick="dialogclose(0)">
                <input id="idx_dlgOkButton" type="button" value="OK" style="" onclick="dialogclose(1)">
                <div><input id="idx_dlgDeleteButton" type="button" value="Delete" style="display:none" onclick="dialogclose(2)"></div>
            </div>
        </div>
    </div>
    <script>
        var random = '{{{randomlength}}}' // Random length string for BREACH mitigation
        var recFile = null;
        var recFilePtr = 0;
        var recFileStartTime = 0;
        var recFileLastTime = 0;
        var recFileEndTime = 0;
        var recFileMetadata = null;
        var recFileProtocol = 0;
        var recFileIndexBasePtr = null;
        var recFileExtras = null;
        var agentDesktop = null;
        var amtDesktop = null;
        var playing = false;
        var readState = 0;
        var waitTimer = null;
        var waitTimerArgs = null;
        var deskAspectRatio = 0;
        var currentDeltaTimeTotalSec = 0;
        var videoWriter = null;
        var videoWriterLastFrame = null;
        var videoWriterCurrentFrame = null;
        var videoFrameDuration = 100;
        var browser = null;
        var domainUrl = '{{{domainurl}}}';
        var urlargs;
        var term = null;

        // Streaming values
        var ws = null;
        var streamingBlockSize = 102400; // 100k block
        var streamingBlockCache = {};

        function start() {
            // Detect what browser is in use
            browser = (function (agent) {
                switch (true) {
                    case agent.indexOf("edge") > -1: return "MS Edge (EdgeHtml)";
                    case agent.indexOf("edg") > -1: return "MS Edge Chromium";
                    case agent.indexOf("opr") > -1 && !!window.opr: return "opera";
                    case agent.indexOf("chrome") > -1 && !!window.chrome: return "chrome";
                    case agent.indexOf("trident") > -1: return "Internet Explorer";
                    case agent.indexOf("firefox") > -1: return "firefox";
                    case agent.indexOf("safari") > -1: return "safari";
                    default: return "other";
                }
            })(window.navigator.userAgent.toLowerCase());

            urlargs = parseUriArgs(true);
            window.onresize = deskAdjust;
            document.ondrop = ondrop;
            document.ondragover = ondragover;
            document.ondragleave = ondragleave;
            document.onkeypress = onkeypress;
            Q('PlaySpeed').value = 1;
            cleanup();

            // Make the dialog box movable
            dialogBoxDrag();

            // Check if we need to stream a session
            if (urlargs.stream != null) {
                QV('metadatadiv', true);
                QH('metadatadiv', "Connecting to server...");
                ws = new WebSocket(window.location.protocol.replace('http', 'ws') + '//' + window.location.host + domainUrl + 'recordings.ashx?file=' + urlargs.stream + (urlargs.key ? ('&key=' + urlargs.key) : ''));
                ws.binaryType = 'arraybuffer';
                ws.onopen = function (e) { console.log('Session Streaming - Connected'); }
                ws.onmessage = function (msg) {
                    if (typeof msg.data != 'string') {
                        var uint8View = new Uint8Array(msg.data);
                        var blocknum = (((uint8View[4] << 24) + (uint8View[5] << 16) + (uint8View[6] << 8) + uint8View[7]) / streamingBlockSize);
                        //console.log('Session Streaming - Got block: ' + blocknum);
                        streamingBlockCache[blocknum] = msg.data;
                        var pendingFetchStreamingData2 = [], pendingFetchStreamingData3 = [];
                        for (var i in pendingFetchStreamingData) {
                            var j = pendingFetchStreamingData[i].missingBlocks.indexOf(blocknum);
                            if (j >= 0) { pendingFetchStreamingData[i].missingBlocks.splice(i, 1); }
                            if (pendingFetchStreamingData[i].missingBlocks.length == 0) {
                                pendingFetchStreamingData3.push(pendingFetchStreamingData[i]);
                            } else {
                                pendingFetchStreamingData2.push(pendingFetchStreamingData[i]);
                            }
                        }
                        pendingFetchStreamingData = pendingFetchStreamingData2;
                        for (var i in pendingFetchStreamingData3) {
                            fetchStreamingData(pendingFetchStreamingData3[i].fr, pendingFetchStreamingData3[i].start, pendingFetchStreamingData3[i].end);
                        }
                        return;
                    } else {
                        var command = null;
                        try { command = JSON.parse(msg.data); } catch (ex) { console.log(ex); return; }
                        if ((command == null) || (typeof command.action != 'string')) return;
                        switch (command.action) {
                            case 'info': {
                                console.log('Session Streaming - Session file size: ' + command.size);
                                if ((typeof command.name != 'string') || (typeof command.size != 'number')) break;
                                recFile = { name: command.name, size: command.size, streaming: true };
                                readLastBlock(function (type, flags, time, extras) {
                                    if (type == 3) {
                                        // File is ok
                                        recFileEndTime = time;
                                        recFileExtras = extras;
                                        readNextBlock(processFirstBlock);
                                    } else {
                                        // This is not a good file
                                        recFileEndTime = 0;
                                    }
                                });
                                break;
                            }
                        }

                    }
                }
                ws.onclose = function (e) {
                    console.log('Session Streaming - Disconnected');
                    ws = null;
                    urlargs.stream = null;
                    QV('OpenFileButton', true);
                    cleanup();
                }
            } else {
                QV('OpenFileButton', true);
            }
        }

        // Pending fetch requests
        var pendingFetchStreamingData = [];

        // Get a section of the recorded file
        function fetchStreamingData(fr, start, end) {
            // Start by looking at what blocks are required
            var firstBlock = Math.floor(start / streamingBlockSize);
            var lastBlock = Math.floor(end / streamingBlockSize);
            var missingBlocks = [];
            for (var i = firstBlock; i <= lastBlock; i++) {
                if ((streamingBlockCache[i] == null) || (streamingBlockCache[i] === 1)) { missingBlocks.push(i); fetchStreamingBlock(i); }
                fetchStreamingBlock(i + 1); // Pre-fetch block
                fetchStreamingBlock(i + 2); // Pre-fetch block
            }
            if (missingBlocks.length == 0) {
                // We have all the blocks we need, assemble the data now
                var outputptr = 0;
                var output = new ArrayBuffer(end - start);
                var outputBytes = new Uint8Array(output);
                for (var i = firstBlock; i <= lastBlock; i++) {
                    var block = streamingBlockCache[i]; // Get a block with data we need
                    var blockstart = (i * streamingBlockSize); // Compute the block starting data pointer
                    var blockend = blockstart + (block.byteLength - 8); // Compute the block ending data pointer
                    var r1 = Math.max(start, blockstart); // Compute where we need to start data copy
                    var r2 = Math.min(end, blockend); // Compute where we need to end data copy
                    var p1 = r1 - blockstart; // Compute where in the block to start data copy
                    var p2 = r2 - r1; // Computer how many byte to copy from the block
                    var subblock = block.slice(8 + p1, 8 + p1 + p2); // Get the sub-block of data we need
                    outputBytes.set(new Uint8Array(subblock), outputptr); // Copy the sub-block into the main block
                    outputptr += p2; // Move the pointer forward
                }
                fr.onload({ target: { result: ArrayBufferToString(output) } } ); // Event the block of data
            } else {
                pendingFetchStreamingData.push({ fr: fr, start: start, end: end, missingBlocks: missingBlocks });
            }
        }

        // Request a block of data from the server
        function fetchStreamingBlock(n) {
            if (streamingBlockCache[n] != null) return;
            streamingBlockCache[n] = 1; // Mark the block as being requested
            if ((n * streamingBlockSize) >= recFile.size) return;
            var len = streamingBlockSize;
            if (((n + 1) * streamingBlockSize) >= recFile.size) { len = (recFile.size - (n * streamingBlockSize)); }
            ws.send('{"action":"get","ptr":' + (n * streamingBlockSize) + ',"size":' + len + '}');
        }

        function readNextBlock(func) {
            if ((recFilePtr + 16) > recFile.size) { QS('progressbar').width = '100%'; func(-1); } else {
                var fr = new FileReader();
                fr.onload = function (r) {
                    var result = r.target.result;
                    var type = ReadShort(result, 0);
                    var flags = ReadShort(result, 2);
                    var size = ReadInt(result, 4);
                    var time = (ReadInt(result, 8) << 32) + ReadInt(result, 12);
                    if ((recFilePtr + 16 + size) > recFile.size) { QS('progressbar').width = '100%'; func(-1); } else {
                        var fr2 = new FileReader();
                        fr2.onload = function (r) {
                            var result = r.target.result;
                            recFilePtr += (16 + size);
                            if (recFileEndTime == 0) {
                                // File pointer progress bar
                                QS('progressbar').width = Math.floor(100 * (recFilePtr / recFile.size)) + '%';
                            } else {
                                // Time progress bar
                                QS('progressbar').width = Math.floor(((recFileLastTime - recFileStartTime) / (recFileEndTime - recFileStartTime)) * 100) + '%';
                            }
                            func(type, flags, time, result);
                        };
                        if (ws == null) {
                            fr2.readAsBinaryString(recFile.slice(recFilePtr + 16, recFilePtr + 16 + size));
                        } else {
                            fetchStreamingData(fr2, recFilePtr + 16, recFilePtr + 16 + size);
                        }
                    }
                };
                if (ws == null) {
                    fr.readAsBinaryString(recFile.slice(recFilePtr, recFilePtr + 16));
                } else {
                    fetchStreamingData(fr, recFilePtr, recFilePtr + 16);
                }
            }
        }

        function readBlockAt(ptr, func) {
            var fr = new FileReader();
            fr.onload = function (r) {
                var result = r.target.result;
                var type = ReadShort(result, 0);
                var flags = ReadShort(result, 2);
                var size = ReadInt(result, 4);
                var time = (ReadInt(result, 8) << 32) + ReadInt(result, 12);
                if ((ptr + 16 + size) > recFile.size) { func(-1); } else {
                    var fr2 = new FileReader();
                    fr2.onload = function (r) {
                        var result = r.target.result;
                        func(type, flags, time, result);
                    };
                    if (ws == null) {
                        fr2.readAsBinaryString(recFile.slice(ptr + 16, ptr + 16 + size));
                    } else {
                        fetchStreamingData(fr2, ptr + 16, ptr + 16 + size);
                    }
                }
            };
            if (ws == null) {
                fr.readAsBinaryString(recFile.slice(ptr, ptr + 16));
            } else {
                fetchStreamingData(fr, ptr, ptr + 16);
            }
        }

        function readLastBlock(func) {
            if (recFile.size < 32) { func(-1); } else {
                var fr = new FileReader();
                fr.onload = function (r) {
                    var result = r.target.result;
                    var type = ReadShort(result, 0);
                    var flags = ReadShort(result, 2);
                    var size = ReadInt(result, 4);
                    var time = (ReadInt(result, 8) << 32) + ReadInt(result, 12);
                    var magic = result.substring(16, 32);
                    if ((type == 3) && (size == 16) && (magic == 'MeshCentralMCNDX')) {
                        // Extra metadata present, lets read it.
                        var fr2 = new FileReader();
                        fr2.onload = function (r) {
                            var result = r.target.result;
                            var xtype = ReadShort(result, 0);
                            var xflags = ReadShort(result, 2);
                            var xsize = ReadInt(result, 4);
                            var xtime = (ReadInt(result, 8) << 32) + ReadInt(result, 12);
                            var extras = JSON.parse(result.substring(16));
                            func(type, flags, xtime, extras); // Include extra metadata
                        }
                        if (ws == null) {
                            fr2.readAsBinaryString(recFile.slice(time, recFile.size - 32));
                        } else {
                            fetchStreamingData(fr2, time, recFile.size - 32);
                        }
                    } else if ((type == 3) && (size == 16) && (magic == 'MeshCentralMCREC')) {
                        func(type, flags, time); // No extra metadata
                    } else {
                        func(-1); // Fail
                    }
                };
                if (ws == null) {
                    fr.readAsBinaryString(recFile.slice(recFile.size - 32, recFile.size));
                } else {
                    fetchStreamingData(fr, recFile.size - 32, recFile.size);
                }
            }
        }

        function addInfo(name, value) { if (value == null) return ''; return addInfoNoEsc(name, EscapeHtml(value)); }

        function addInfoNoEsc(name, value) {
            if (value == null) return '';
            return '<span style=color:gray>' + EscapeHtml(name) + '</span>:&nbsp;<span style=font-size:20px>' + value + '</span><br/>';
        }

        function processFirstBlock(type, flags, time, data) {
            recFileProtocol = 0;
            if ((type != 1) || (flags > 2)) { cleanup(); return; }
            try { recFileMetadata = JSON.parse(data) } catch (ex) { cleanup(); return; }
            if ((recFileMetadata == null) || (recFileMetadata.magic != 'MeshCentralRelaySession') || (recFileMetadata.ver != 1)) { cleanup(); return; }
            if (recFileExtras) { for (var i in recFileExtras) { recFileMetadata[i] = recFileExtras[i]; } }
            var x = '';
            x += addInfo("Time", recFileMetadata.time);
            if (recFileEndTime != 0) { var secs = Math.floor((recFileEndTime - time) / 1000); x += addInfo("Duration", format("{0} second{1}", secs, (secs > 1) ? 's' : '')); }
            x += addInfo("Username", recFileMetadata.username);
            x += addInfo("UserID", recFileMetadata.userid);
            x += addInfo("SessionID", recFileMetadata.sessionid);
            if (recFileMetadata.ipaddr1 && recFileMetadata.ipaddr2) { x += addInfo("Addresses", format("{0} to {1}", recFileMetadata.ipaddr1, recFileMetadata.ipaddr2)); }
            if (recFileMetadata.devicename) { x += addInfo("Device Name", recFileMetadata.devicename); }
            x += addInfo("NodeID", recFileMetadata.nodeid);
            if (recFileMetadata.protocol) {
                var p = recFileMetadata.protocol;
                if (p == 1) { p = "MeshCentral Terminal"; }
                else if (p == 2) { p = "MeshCentral Desktop"; }
                else if (p == 100) { p = "Intel&reg; AMT WSMAN"; }
                else if (p == 101) { p = "Intel&reg; AMT Redirection"; }
                else if (p == 200) { p = "Intel&reg; AMT KVM"; }
                x += addInfoNoEsc("Protocol", p);
            }
            var encQualityStr = "2 byte-per-pixel";
            if (recFileMetadata.bpp == 1) { encQualityStr = "1 byte-per-pixel" }
            if (recFileMetadata.graymode) { if (recFileMetadata.lowcolor) { encQualityStr += ", 16 grays"; } else { encQualityStr += ", 256 grays"; } }
            x += addInfoNoEsc("Encoding Quality", encQualityStr);

            if (recFileMetadata.indexInterval) {
                recFileIndexBasePtr = recFilePtr;
                x += addInfoNoEsc("Seeking", format("Indexed every {0} seconds", recFileMetadata.indexInterval));
                QV('SeekBackwardButton', true);
                QV('SeekForwardButton', true);
                QE('SeekBackwardButton', true);
                QE('SeekForwardButton', true);
            } else {
                QV('SeekBackwardButton', false);
                QV('SeekForwardButton', false);
            }
            QV('DeskParent', true);
            QV('TermParent', false);
            QV('XTermParent', false);
            QV('ConvertAsWebM', false);
            if (recFileMetadata.protocol == 1) {
                // MeshCentral remote terminal
                recFileProtocol = 1;
                x += '<br /><br /><span style=color:gray>' + "Press [space] to play/pause." + '</span>';
                QE('PlayButton', true);
                QE('PauseButton', false);
                QE('RestartButton', false);
                recFileStartTime = recFileLastTime = time;
            }
            else if (recFileMetadata.protocol == 2) {
                // MeshCentral remote desktop
                recFileProtocol = 2;
                x += '<br /><br /><span style=color:gray>' + "Press [space] to play/pause." + '</span>';
                QE('PlayButton', true);
                QE('PauseButton', false);
                QE('RestartButton', false);
                recFileStartTime = recFileLastTime = time;
                agentDesktop = CreateAgentRemoteDesktop('Desk');
                agentDesktop.onScreenSizeChange = deskAdjust;
                agentDesktop.onPreDrawImage = preCanvasDraw;
                agentDesktop.State = 3;
                deskAdjust();
                QV('ConvertAsWebM', browser == 'chrome'); // Only show the "Convert to WebM button when in Chrome
            }
            else if (recFileMetadata.protocol == 101) {
                // Intel AMT Redirection
                recFileProtocol = 101;
                x += '<br /><br /><span style=color:gray>' + "Press [space] to play/pause." + '</span>';
                QE('PlayButton', true);
                QE('PauseButton', false);
                QE('RestartButton', false);
                recFileStartTime = recFileLastTime = time;
                amtDesktop = CreateAmtRemoteDesktop('Desk');
                amtDesktop.onScreenSizeChange = deskAdjust;
                amtDesktop.onPreDrawImage = preCanvasDraw;
                if (recFileMetadata.screenSize) { amtDesktop.width = recFileMetadata.screenSize[0]; amtDesktop.height = recFileMetadata.screenSize[1]; }
                if (recFileMetadata.bpp) { amtDesktop.bpp = recFileMetadata.bpp; }
                if (recFileMetadata.graymode) { amtDesktop.graymode = recFileMetadata.graymode; }
                if (recFileMetadata.lowcolor) { amtDesktop.lowcolor = recFileMetadata.lowcolor; }
                amtDesktop.State = 3;
                amtDesktop.Start();
                deskAdjust();
            }
            else if (recFileMetadata.protocol == 200) {
                // Intel AMT Midstream KVM
                recFileProtocol = 200;
                x += '<br /><br /><span style=color:gray>' + "Press [space] to play/pause." + '</span>';
                QE('PlayButton', true);
                QE('PauseButton', false);
                QE('RestartButton', false);
                recFileStartTime = recFileLastTime = time;
                amtDesktop = CreateAmtRemoteDesktop('Desk');
                amtDesktop.onScreenSizeChange = deskAdjust;
                amtDesktop.onPreDrawImage = preCanvasDraw;
                amtDesktop.State = 3;
                amtDesktop.Start();
                if (recFileMetadata.screenSize) { amtDesktop.width = recFileMetadata.screenSize[0]; amtDesktop.height = recFileMetadata.screenSize[1]; }
                if (recFileMetadata.bpp) { amtDesktop.bpp = recFileMetadata.bpp; }
                if (recFileMetadata.graymode) { amtDesktop.graymode = recFileMetadata.graymode; }
                if (recFileMetadata.lowcolor) { amtDesktop.lowcolor = recFileMetadata.lowcolor; }
                amtDesktop.state = 3;
                deskAdjust();
                QV('ConvertAsWebM', browser == 'chrome'); // Only show the "Convert to WebM button when in Chrome
            }
            QV('metadatadiv', true);
            QH('metadatadiv', x);
            QH('deskstatus', recFile.name);
            QS('progressbar').width = '0px';
        }

        function processBlock(type, flags, time, data) {
            if (type < 0) { pause(); return; }
            var waitTime = Math.round((time - recFileLastTime) * parseFloat(Q('PlaySpeed').value));
            if ((waitTime < 5) || (videoWriter != null)) {
                processBlockEx(type, flags, time, data);
            } else {
                waitTimerArgs = [type, flags, time, data]
                waitTimer = setTimeout(function () { waitTimer = null; if (waitTimerArgs) { processBlockEx(waitTimerArgs[0], waitTimerArgs[1], waitTimerArgs[2], waitTimerArgs[3]); } }, waitTime);
            }
        }

        function processBlockEx(type, flags, time, data, forced) {
            if ((playing == false) && (forced !== true)) return;
            var flagBinary = (flags & 1) != 0, flagUser = (flags & 2) != 0;

            // End of the stream, close the WebM converter
            if ((type == 3) && (videoWriter != null)) {
                preCanvasDraw();
                videoWriter.complete().then(function (webMBlob) {
                    saveAs(webMBlob, recFile.name.replace('.mcrec', '.webm'));
                    videoWriter = null;
                    QE('PlaySpeed', true);
                    QE('SeekBackwardButton', true);
                    QE('SeekForwardButton', true);
                    QE('ConvertAsWebM', true);
                    QE('OpenFileButton', true);
                });
            }

            if (type == 2) {
                // Update the clock
                recFileLastTime = time;
                var deltaTimeTotalSec = Math.floor((time - recFileStartTime) / 1000);
                if (currentDeltaTimeTotalSec != deltaTimeTotalSec) {
                    // Hours, minutes and seconds
                    currentDeltaTimeTotalSec = deltaTimeTotalSec;
                    var hrs = Math.floor(deltaTimeTotalSec / 3600);
                    var mins = Math.floor((deltaTimeTotalSec % 3600) / 60);
                    var secs = Math.floor(deltaTimeTotalSec % 60);
                    QH('timespan', pad2(hrs) + ':' + pad2(mins) + ':' + pad2(secs))
                }

                // Set the initial time on the WebM movie writer if needed
                if (videoWriterLastFrame == null) { videoWriterLastFrame = time; }
                videoWriterCurrentFrame = time;
            }

            // MeshCentral Terminal options
            if ((type == 2) && !flagBinary && flagUser && (data.length > 2) && (data[0] == '{')) {
                var parsed = null;
                try { parsed = JSON.parse(data); } catch (ex) { }
                if ((parsed != null) && ((parsed.type == 'options') || (parsed.type == 'termsize')) && (typeof parsed.cols == 'number') && (typeof parsed.rows == 'number')) {
                    term.resize(parsed.cols, parsed.rows);
                    //console.log('termsize', parsed.cols, parsed.rows);
                }
            }

            if ((type == 2) && flagBinary && !flagUser) {
                // Device --> User data
                if (recFileProtocol == 1) {
                    // MeshCentral Terminal
                    writeXTerm(data);
                } else if (recFileProtocol == 2) {
                    // MeshCentral Remote Desktop
                    var view = new Uint8Array(data.length);
                    for (var i = 0; i < data.length; i++) { view[i] = data.charCodeAt(i); }

                    // Accumulator is not active
                    var cmd = (view[0] << 8) + view[1], cmdsize = (view[2] << 8) + view[3];
                    if ((cmd == 27) && (cmdsize == 8)) { cmd = (view[8] << 8) + view[9]; cmdsize = (view[5] << 16) + (view[6] << 8) + view[7]; view = view.slice(8); }
                    if (cmdsize != view.byteLength) {
                        console.log('Bad command size', cmd, cmdsize, view.byteLength);
                    } else {
                        agentDesktop.ProcessBinaryCommand(cmd, cmdsize, view.slice(0, cmdsize));
                    }
                } else if (recFileProtocol == 101) {
                    // Intel AMT KVM
                    var view = new Uint8Array(data.length);
                    for (var i = 0; i < data.length; i++) { view[i] = data.charCodeAt(i); }

                    if ((readState == 0) && (rstr2hex(data) == '4100000000000000')) {
                        // We are not authenticated, KVM data starts here.
                        readState = 1;
                        if (data.length > 8) { amtDesktop.ProcessBinaryData(view.slice(8).buffer); }
                    } else if (readState == 1) {
                        amtDesktop.ProcessBinaryData(view.buffer);
                    }
                } else if (recFileProtocol == 200) {
                    // Intel AMT midstream KVM
                    var view = new Uint8Array(data.length);
                    for (var i = 0; i < data.length; i++) { view[i] = data.charCodeAt(i); }
                    amtDesktop.ProcessBinaryData(view.buffer);
                }
            } else if ((type == 2) && flagBinary && flagUser) {
                // User --> Device data
                if (recFileProtocol == 101) {
                    // Intel AMT KVM
                    if (rstr2hex(data) == '0000000008080001000700070003050200000000') { console.log('RGB8'); amtDesktop.bpp = 1; } // Switch to 1 byte per pixel, 256 colors
                    if (rstr2hex(data) == '000000000808000100FF00000000000000000000') { console.log('GRAY8'); amtDesktop.bpp = 1; obj.graymode = true; } // Switch to 1 byte per pixel, 256 grays
                    if (rstr2hex(data) == '0000000008040001000F00000000000000000000') { console.log('GRAY4'); amtDesktop.bpp = 1; obj.graymode = true; obj.lowcolor = true; } // Switch to 1 byte per pixel, 16 grays
                }
            }

            // This is a PNG screenshot of the display, load it and render it.
            if ((type == 3) && (recFileProtocol == 200)) {
                var tile = new Image();
                tile.src = "data:image/png;base64," + btoa(data);
                tile.onload = function () { amtDesktop.canvas.drawImage(tile, 0, 0); }
                tile.error = function () { }
            }

            if (playing) { readNextBlock(processBlock); }
        }

        function cleanup() {
            clearXTerm();
            recFile = null;
            recFilePtr = 0;
            recFileMetadata = null;
            playing = false;
            if (agentDesktop != null) { agentDesktop.Canvas.clearRect(0, 0, agentDesktop.CanvasId.width, agentDesktop.CanvasId.height); agentDesktop = null; }
            if (amtDesktop != null) { amtDesktop.canvas.clearRect(0, 0, amtDesktop.CanvasId.width, amtDesktop.CanvasId.height); amtDesktop = null; }
            readState = 0;
            waitTimerArgs = null;
            currentDeltaTimeTotalSec = 0;
            recFileEndTime = 0;
            agentTerminal = null;
            if (waitTimer != null) { clearTimeout(waitTimer); waitTimer = null; }
            QH('deskstatus', '');
            QE('PlayButton', false);
            QE('PauseButton', false);
            QE('RestartButton', false);
            QE('SeekBackwardButton', false);
            QE('SeekForwardButton', false);
            QS('progressbar').width = '0px';
            QH('timespan', '00:00:00');
            QV('metadatadiv', true);
            if (urlargs.stream == null) {
                QH('metadatadiv', '<span style=\"font-family:Arial,Helvetica Neue,Helvetica,sans-serif;font-size:28px\">MeshCentral Session Player</span><br /><br /><span style=color:gray>' + "Drag & drop a .mcrec file or click \"Open File...\"" + '</span>');
            } else {
                QH('metadatadiv', '');
            }
            QV('DeskParent', true);
            QV('TermParent', false);
            QV('XTermParent', false);
        }

        function ondrop(e) {
            if (xxdialogMode) return;
            haltEvent(e);
            QV('bigfail', false);
            QV('bigok', false);

            // Check if these are files we can upload, remove all folders.
            if (e.dataTransfer == null) return;
            var files = [];
            for (var i in e.dataTransfer.files) {
                if ((e.dataTransfer.files[i].type != null) && (e.dataTransfer.files[i].size != null) && (e.dataTransfer.files[i].size != 0) && (e.dataTransfer.files[i].name.endsWith('.mcrec'))) {
                    files.push(e.dataTransfer.files[i]);
                }
            }
            if (files.length == 0) return;
            cleanup();
            recFile = files[0];
            recFilePtr = 0;
            readLastBlock(function (type, flags, time, extras) {
                if (type == 3) {
                    // File is ok
                    recFileEndTime = time;
                    recFileExtras = extras;
                    readNextBlock(processFirstBlock);
                } else {
                    // This is not a good file
                    recFileEndTime = 0;
                }
            });
        }

        var dragtimer = null;
        function ondragover(e) {
            if (xxdialogMode) return;
            haltEvent(e);
            if (dragtimer != null) { clearTimeout(dragtimer); dragtimer = null; }
            var ac = true;
            QV('bigok', ac);
            QV('bigfail', !ac);
        }

        function ondragleave(e) {
            if (xxdialogMode) return;
            haltEvent(e);
            dragtimer = setTimeout(function () { QV('bigfail', false); QV('bigok', false); dragtimer = null; }, 10);
        }

        function onkeypress(e) {
            if (xxdialogMode) return;
            if (e.key == ' ') { togglePause(); haltEvent(e); }
            if (e.key == '1') { Q('PlaySpeed').value = 4; haltEvent(e); }
            if (e.key == '2') { Q('PlaySpeed').value = 2; haltEvent(e); }
            if (e.key == '3') { Q('PlaySpeed').value = 1; haltEvent(e); }
            if (e.key == '4') { Q('PlaySpeed').value = 0.5; haltEvent(e); }
            if (e.key == '5') { Q('PlaySpeed').value = 0.25; haltEvent(e); }
            if (e.key == '6') { Q('PlaySpeed').value = 0.1; haltEvent(e); }
            if (e.key == '0') { pause(); restart(); haltEvent(e); }
        }

        function saveAsWebMfile() {
            var x = '';
            x += addHtmlValue4("Frame rate", '<select id=webmframerate style=width:200px><option value=100 selected>' + "10 frames/sec" + '</option><option value=50>' + "20 frames/sec" + '</option></select>');
            x += addHtmlValue4("Quality", '<select id=webmquality style=width:200px><option value=90>' + "90%" + '</option><option value=80>' + "80%" + '</option><option value=60 selected>' + "60%" + '</option><option value=40>' + "40%" + '</option><option value=20>' + "20%" + '</option><option value=10>' + "10%" + '</option></select>');
            setDialogMode(2, "Convert to WebM", 3, saveAsWebMfileEx, x);
        }

        // Convert the remote desktop or KVM file into a WebM movie file.
        function saveAsWebMfileEx() {
            videoFrameDuration = parseInt(Q('webmframerate').value);
            var quality = parseInt(Q('webmquality').value) / 100;
            //console.log(videoFrameDuration, quality);
            videoWriterLastFrame = null;
            videoWriter = new WebMWriter({ quality: quality, frameDuration: 100, transparent: false });
            restart();
            play();
            QE('PlayButton', false);
            QE('PauseButton', false);
            QE('RestartButton', false);
            QE('PlaySpeed', false);
            QE('SeekBackwardButton', false);
            QE('SeekForwardButton', false);
            QE('ConvertAsWebM', false);
            QE('OpenFileButton', false);
        }

        function preCanvasDraw() {
            if (videoWriter) {
                var delta = videoWriterCurrentFrame - videoWriterLastFrame;
                if (delta >= videoFrameDuration) { videoWriter.addFrame(Q('Desk'), delta); videoWriterLastFrame = videoWriterCurrentFrame; }
            }
        }

        function openfile() {
            if (xxdialogMode) return;
            var x = '<input type=file name=files id=p2fileinput style=width:100% accept=".mcrec" onchange="openfileChanged()" />';
            setDialogMode(2, "Open File...", 3, openfileEx, x);
            QE('idx_dlgOkButton', false);
        }

        function openfileEx() {
            var xfiles = Q('p2fileinput').files;
            if (xfiles != null) { var files = []; for (var i in xfiles) { if ((xfiles[i].type != null) && (xfiles[i].size != null) && (xfiles[i].size != 0) && (xfiles[i].name.endsWith('.mcrec'))) { files.push(xfiles[i]); } } }
            if (files.length == 0) return;
            cleanup();
            recFile = files[0];
            recFilePtr = 0;
            readLastBlock(function (type, flags, time, extras) {
                if (type == 3) {
                    // File is ok
                    recFileEndTime = time;
                    recFileExtras = extras;
                    readNextBlock(processFirstBlock);
                } else {
                    // This is not a good file
                    recFileEndTime = 0;
                }
            });
            Q('OpenFileButton').blur();
        }

        function openfileChanged() {
            var xfiles = Q('p2fileinput').files;
            if (xfiles != null) { var files = []; for (var i in xfiles) { if ((xfiles[i].type != null) && (xfiles[i].size != null) && (xfiles[i].size != 0) && (xfiles[i].name.endsWith('.mcrec'))) { files.push(xfiles[i]); } } }
            QE('idx_dlgOkButton', files.length == 1);
        }

        function togglePause() {
            if (xxdialogMode) return;
            if (term != null) return;
            if (recFile != null) { if (playing == true) { pause(); } else { if (recFilePtr != recFile.size) { play(); } } } return false;
        }

        function play() {
            if (xxdialogMode) return;
            Q('PlayButton').blur();
            if ((playing == true) || (recFileProtocol == 0)) return;
            playing = true;
            QV('metadatadiv', false);
            QE('PlayButton', false);
            QE('PauseButton', true);
            QE('RestartButton', false);
            if ((recFileProtocol == 1) && (term == null)) {
                QV('DeskParent', false);
                QV('TermParent', false);
                QV('XTermParent', true);
                setupXTerm();
                //agentTerminal = CreateAmtRemoteTerminal('Term', {});
                //agentTerminal.State = 3;
            }
            readNextBlock(processBlock);
        }

        function pause() {
            if (xxdialogMode) return;
            Q('PauseButton').blur();
            if (playing == false) return;
            playing = false;
            QE('PlayButton', recFilePtr != recFile.size);
            QE('PauseButton', false);
            QE('RestartButton', recFilePtr != 0);
            if (waitTimer != null) {
                clearTimeout(waitTimer);
                waitTimer = null;
                processBlockEx(waitTimerArgs[0], waitTimerArgs[1], waitTimerArgs[2], waitTimerArgs[3]);
                waitTimerArgs = null;
            }
        }

        function restart() {
            if (xxdialogMode) return;
            Q('RestartButton').blur();
            if (playing == true) return;
            recFilePtr = 0;
            readState = 0;
            currentDeltaTimeTotalSec = 0;
            QV('metadatadiv', true);
            QE('PlayButton', true);
            QE('PauseButton', false);
            QE('RestartButton', false);
            QS('progressbar').width = '0px';
            QH('timespan', '00:00:00');
            QV('DeskParent', true);
            QV('TermParent', false);
            QV('XTermParent', false);
            clearXTerm();
            if (agentDesktop) {
                agentDesktop.Canvas.clearRect(0, 0, agentDesktop.CanvasId.width, agentDesktop.CanvasId.height);
            } else if (amtDesktop) {
                amtDesktop.canvas.clearRect(0, 0, amtDesktop.CanvasId.width, amtDesktop.CanvasId.height);
                amtDesktop = CreateAmtRemoteDesktop('Desk');
                amtDesktop.onScreenSizeChange = deskAdjust;
                amtDesktop.State = 3;
                amtDesktop.Start();
                if (recFileMetadata.protocol == 200) {
                    if (recFileMetadata.screenSize) { amtDesktop.width = recFileMetadata.screenSize[0]; amtDesktop.height = recFileMetadata.screenSize[1]; }
                    if (recFileMetadata.bpp) { amtDesktop.bpp = recFileMetadata.bpp; }
                    if (recFileMetadata.graymode) { amtDesktop.graymode = recFileMetadata.graymode; }
                    if (recFileMetadata.lowcolor) { amtDesktop.lowcolor = recFileMetadata.lowcolor; }
                    amtDesktop.state = 3;
                }
            } else if (agentTerminal) {
                agentTerminal = null;
            }
        }

        function clearConsoleMsg() { QH('p11DeskConsoleMsg', ''); }

        // Toggle the web page to full screen
        function toggleAspectRatio(toggle) {
            if (toggle === 1) { deskAspectRatio = ((deskAspectRatio + 1) % 3); }
            deskAdjust();
        }

        function deskAdjust() {
            var parentH = Q('DeskParent').clientHeight, parentW = Q('DeskParent').clientWidth;
            var deskH = Q('Desk').height, deskW = Q('Desk').width;

            if (deskAspectRatio == 2) {
                // Scale mode
                QS('Desk')['margin-top'] = null;
                QS('Desk').height = '100%';
                QS('Desk').width = '100%';
                QS('DeskParent').overflow = 'hidden';
            } else if (deskAspectRatio == 1) {
                // Zoomed mode
                QS('Desk')['margin-top'] = '0px';
                //QS('Desk')['margin-left'] = '0px';
                QS('Desk').height = deskH + 'px';
                QS('Desk').width = deskW + 'px';
                QS('DeskParent').overflow = 'scroll';
            } else {
                // Fixed aspect ratio
                if ((parentH / parentW) > (deskH / deskW)) {
                    var hNew = ((deskH * parentW) / deskW) + 'px';
                    //if (webPageFullScreen || fullscreen) {
                    //QS('deskarea3x').height = null;
                    //} else {
                    // QS('deskarea3x').height = hNew;
                    //QS('deskarea3x').height = null;
                    //}
                    QS('Desk').height = hNew;
                    QS('Desk').width = '100%';
                } else {
                    var wNew = ((deskW * parentH) / deskH) + 'px';
                    //if (webPageFullScreen || fullscreen) {
                    //QS('Desk').height = null;
                    //} else {
                    QS('Desk').height = '100%';
                    //}
                    QS('Desk').width = wNew;
                }
                QS('Desk')['margin-top'] = null;
                QS('DeskParent').overflow = 'hidden';
            }
        }

        function seekBackward() {
            if (xxdialogMode) return;
            var ndxNumber = Math.round(currentDeltaTimeTotalSec / recFileMetadata.indexInterval);
            if (ndxNumber < 2) {
                pause(); restart();
            } else {
                if (recFileMetadata.indexes[ndxNumber - 2] != null) { seek(ndxNumber - 2); }
            }
        }

        function seekForward() {
            if (xxdialogMode) return;
            var ndxNumber = Math.round(currentDeltaTimeTotalSec / recFileMetadata.indexInterval);
            if (recFileMetadata.indexes[ndxNumber] != null) { seek(ndxNumber); }
        }

        function progressBarSeek(event) {
            var ndxNumber = Math.round((event.clientX / document.body.offsetWidth) * (recFileMetadata.indexes.length + 1)) - 1;
            if (ndxNumber == -1) { pause(); restart(); } else { seek(ndxNumber); }
        }

        var SeekIndex;
        var SeekIndexPtr;
        var SeekIndexTime;
        var SeekPlayState;
        function seek(indexNumber) {
            if (xxdialogMode) return;
            //console.log('seek', indexNumber);
            if ((recFileMetadata.indexes == null) || (recFileMetadata.indexes[indexNumber] == null)) return null;
            SeekPlayState = playing;
            pause();
            restart();
            SeekIndex = recFileMetadata.indexes[indexNumber];
            SeekIndexPtr = 3;
            recFileLastTime = SeekIndexTime = recFileStartTime + ((1 + indexNumber) * recFileMetadata.indexInterval * 1000);
            recFilePtr = recFileIndexBasePtr + SeekIndex[0];
            var width = SeekIndex[1];
            var height = SeekIndex[2];

            if (recFileEndTime == 0) {
                // File pointer progress bar
                QS('progressbar').width = Math.floor(100 * (recFilePtr / recFile.size)) + '%';
            } else {
                // Time progress bar
                QS('progressbar').width = Math.floor(((recFileLastTime - recFileStartTime) / (recFileEndTime - recFileStartTime)) * 100) + '%';
            }

            if (agentDesktop) {
                agentDesktop.Canvas.clearRect(0, 0, agentDesktop.CanvasId.width, agentDesktop.CanvasId.height);
                agentDesktop.ProcessScreenMsg(width, height);
            }

            QV('metadatadiv', false);
            QV('Desk', false);

            seekFetchNext(function () { QV('Desk', true); if (SeekPlayState) { play(); } });
        }

        function seekFetchNext(func) {
            if (SeekIndex[SeekIndexPtr] == null) { func(); return; }
            readBlockAt(recFileIndexBasePtr + SeekIndex[SeekIndexPtr], function (type, flags, time, data) {
                SeekIndexPtr++;
                processBlockEx(type, flags, SeekIndexTime, data, true);
                seekFetchNext(func);
            });
        }

        //
        // POPUP DIALOG
        //

        // null = Hidden, 1 = Generic Message
        var xxdialogMode = 0;
        var xxdialogFunc;
        var xxdialogButtons;
        var xxdialogTag;
        var xxcurrentView = -1;

        // Display a dialog box
        // Parameters: Dialog Mode (0 = none), Dialog Title, Buttons (1 = OK, 2 = Cancel, 3 = OK & Cancel), Call back function(0 = Cancel, 1 = OK), Dialog Content (Mode 2 only)
        function setDialogMode(x, y, b, f, c, tag) {
            xxdialogMode = x;
            xxdialogFunc = f;
            xxdialogButtons = b;
            xxdialogTag = tag;
            QE('idx_dlgOkButton', true);
            QV('idx_dlgOkButton', b & 1);
            QV('idx_dlgCancelButton', b & 2);
            QV('id_dialogclose', (b & 2) || (b & 8));
            QV('idx_dlgDeleteButton', b & 4);
            QV('idx_dlgButtonBar', b & 7);
            if (y) QH('id_dialogtitle', y);
            for (var i = 1; i < 3; i++) { QV('dialog' + i, i == x); } // Edit this line when more dialogs are added
            QV('dialog', x);
            if (c) { if (x == 2) { QH('id_dialogOptions', c); } else { QH('id_dialogMessage', c); } }
        }

        function dialogclose(x) {
            var f = xxdialogFunc, b = xxdialogButtons, t = xxdialogTag;
            setDialogMode();
            if (((b & 8) || x) && f) f(x, t);
        }

        function messagebox(t, m) { setSessionActivity(); QH('id_dialogMessage', m); setDialogMode(1, t, 1); }
        function statusbox(t, m) { setSessionActivity(); QH('id_dialogMessage', m); setDialogMode(1, t); }
        function haltEvent(e) { if (e.preventDefault) e.preventDefault(); if (e.stopPropagation) e.stopPropagation(); return false; }
        function pad2(num) { var s = '00' + num; return s.substr(s.length - 2); }
        function format(format) { var args = Array.prototype.slice.call(arguments, 1); return format.replace(/{(\d+)}/g, function (match, number) { return typeof args[number] != 'undefined' ? args[number] : match; }); };

        function addHtmlValue(t, v) { return '<table><td style=width:120px>' + t + '<td><b>' + v + '</b></table>'; }
        function addHtmlValue2(t, v) { return '<div><div style=display:inline-block;float:right>' + v + '</div><div style=display:inline-block>' + t + '</div></div>'; }
        function addHtmlValue3(t, v) { return '<div><b>' + t + '</b></div><div style=margin-left:16px>' + v + '</div>'; }
        function addHtmlValue4(t, v) { return '<table style=width:100%><td style=width:120px>' + t + '<td style=text-align:right><b>' + v + '</b></table>'; }
        function addHtmlValue5(t, v) { return '<div style=padding:4px><div style=display:inline-block;float:right><b>' + v + '</b></div><div style=display:inline-block>' + t + '</div></div>'; }

        // Make the dialog box movable
        function dialogBoxDrag() {
            var elmnt = Q('dialog');
            var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            Q('dialogHeader').onmousedown = dragMouseDown;
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                elmnt.style.top = (elmnt.offsetTop - pos2) + 'px';
                elmnt.style.left = (elmnt.offsetLeft - pos1) + 'px';
            }
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        // This method has caused exceptions: https://github.com/Ylianst/MeshCentral/issues/4302
        function ArrayBufferToString(buffer) {
            try { return BinaryToString(String.fromCharCode.apply(null, Array.prototype.slice.apply(new Uint8Array(buffer)))); } catch (ex) { }
            console.log('ArrayBufferToString - Unable to convert ' + buffer.byteLength + ' bytes.');
            var s = '', u = new Uint8Array(buffer);
            for (var i = 0; i < buffer.byteLength; i++) { s += String.fromCharCode(u[i]); }
            return s;
        }

        function StringToArrayBuffer(string) {
            return StringToUint8Array(string).buffer;
        }

        function BinaryToString(binary) {
            var error;
            try {
                return decodeURIComponent(escape(binary));
            } catch (_error) {
                error = _error;
                if (error instanceof URIError) { return binary; } else { throw error; }
            }
        }

        function StringToBinary(string) {
            var chars, code, i, isUCS2, len, _i;
            len = string.length;
            chars = [];
            isUCS2 = false;
            for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
                code = String.prototype.charCodeAt.call(string, i);
                if (code > 255) { isUCS2 = true; chars = null; break; } else { chars.push(code); }
            }
            if (isUCS2 === true) {
                return unescape(encodeURIComponent(string));
            } else {
                return String.fromCharCode.apply(null, Array.prototype.slice.apply(chars));
            }
        }

        function StringToUint8Array(string) {
            var binary, binLen, buffer, chars, i, _i;
            binary = StringToBinary(string);
            binLen = binary.length;
            buffer = new ArrayBuffer(binLen);
            chars = new Uint8Array(buffer);
            for (i = _i = 0; 0 <= binLen ? _i < binLen : _i > binLen; i = 0 <= binLen ? ++_i : --_i) { chars[i] = String.prototype.charCodeAt.call(binary, i); }
            return chars;
        }

        function setupXTerm() {
            // Setup the terminal
            if (term != null) { term.dispose(); }
            term = new Terminal();
            term.open(Q('XTermParent'));
            term.onData(function (data) { if (tunnel != null) { tunnel.sendText(data); } })
            term.resize(80, 25);
            //term.setOption('convertEol', true); // Consider \n to be \r\n, this should be taken care of by "termios"
        }

        function clearXTerm() {
            if (term != null) { term.dispose(); term = null; }
        }

        function writeXTerm(data) {
            if (term == null) return;
            if (term.writeUtf8) {
                if (typeof data == 'string') { term.writeUtf8(data); } else { term.writeUtf8(new Uint8Array(data)); }
            } else {
                if (typeof data == 'string') { term.write(data); } else { term.write(new Uint8Array(data)); }
            }
        }

        start();
    </script>
</body>
</html>